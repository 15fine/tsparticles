{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Linker = void 0;\n\nvar Utils_1 = require(\"../../Utils\");\n\nvar Linker = function () {\n  function Linker(container) {\n    _classCallCheck(this, Linker);\n\n    this.container = container;\n  }\n\n  _createClass(Linker, [{\n    key: \"isEnabled\",\n    value: function isEnabled(particle) {\n      return particle.particlesOptions.links.enable;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {}\n  }, {\n    key: \"interact\",\n    value: function interact(p1) {\n      var _a;\n\n      var container = this.container;\n      var linkOpt1 = p1.particlesOptions.links;\n      var optOpacity = linkOpt1.opacity;\n      var optDistance = (_a = p1.linksDistance) !== null && _a !== void 0 ? _a : container.retina.linksDistance;\n      var canvasSize = container.canvas.size;\n      var warp = linkOpt1.warp;\n      var pos1 = p1.getPosition();\n      var range = warp ? new Utils_1.CircleWarp(pos1.x, pos1.y, optDistance, canvasSize) : new Utils_1.Circle(pos1.x, pos1.y, optDistance);\n      var query = container.particles.quadTree.query(range);\n\n      for (var _iterator = _createForOfIteratorHelperLoose(query), _step; !(_step = _iterator()).done;) {\n        var p2 = _step.value;\n        var linkOpt2 = p2.particlesOptions.links;\n\n        if (p1 === p2 || !linkOpt2.enable || linkOpt1.id !== linkOpt2.id || p2.spawning || p2.destroyed) {\n          continue;\n        }\n\n        var pos2 = p2.getPosition();\n        var distance = Utils_1.NumberUtils.getDistance(pos1, pos2);\n\n        if (warp) {\n          if (distance > optDistance) {\n            var pos2NE = {\n              x: pos2.x - canvasSize.width,\n              y: pos2.y\n            };\n            distance = Utils_1.NumberUtils.getDistance(pos1, pos2NE);\n\n            if (distance > optDistance) {\n              var pos2SE = {\n                x: pos2.x - canvasSize.width,\n                y: pos2.y - canvasSize.height\n              };\n              distance = Utils_1.NumberUtils.getDistance(pos1, pos2SE);\n\n              if (distance > optDistance) {\n                var pos2SW = {\n                  x: pos2.x,\n                  y: pos2.y - canvasSize.height\n                };\n                distance = Utils_1.NumberUtils.getDistance(pos1, pos2SW);\n              }\n            }\n          }\n        }\n\n        if (distance > optDistance) {\n          return;\n        }\n\n        var opacityLine = (1 - distance / optDistance) * optOpacity;\n        var linksOptions = p1.particlesOptions.links;\n        var linkColor = linksOptions.id !== undefined ? container.particles.linksColors.get(linksOptions.id) : container.particles.linksColor;\n\n        if (!linkColor) {\n          var optColor = linksOptions.color;\n          linkColor = Utils_1.ColorUtils.getLinkRandomColor(optColor, linksOptions.blink, linksOptions.consent);\n\n          if (linksOptions.id !== undefined) {\n            container.particles.linksColors.set(linksOptions.id, linkColor);\n          } else {\n            container.particles.linksColor = linkColor;\n          }\n        }\n\n        if (p2.links.map(function (t) {\n          return t.destination;\n        }).indexOf(p1) === -1 && p1.links.map(function (t) {\n          return t.destination;\n        }).indexOf(p2) === -1) {\n          p1.links.push({\n            destination: p2,\n            opacity: opacityLine\n          });\n        }\n      }\n    }\n  }]);\n\n  return Linker;\n}();\n\nexports.Linker = Linker;","map":{"version":3,"sources":["/Users/matteo/Projects/GitHub Projects/tsparticles/tsparticles-master/demo/react-native/node_modules/react-native-tsparticles/node_modules/tsparticles/dist/Interactions/Particles/Linker.js"],"names":["Object","defineProperty","exports","value","Linker","Utils_1","require","container","particle","particlesOptions","links","enable","p1","_a","linkOpt1","optOpacity","opacity","optDistance","linksDistance","retina","canvasSize","canvas","size","warp","pos1","getPosition","range","CircleWarp","x","y","Circle","query","particles","quadTree","p2","linkOpt2","id","spawning","destroyed","pos2","distance","NumberUtils","getDistance","pos2NE","width","pos2SE","height","pos2SW","opacityLine","linksOptions","linkColor","undefined","linksColors","get","linksColor","optColor","color","ColorUtils","getLinkRandomColor","blink","consent","set","map","t","destination","indexOf","push"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Linker = void 0;\nconst Utils_1 = require(\"../../Utils\");\nclass Linker {\n    constructor(container) {\n        this.container = container;\n    }\n    isEnabled(particle) {\n        return particle.particlesOptions.links.enable;\n    }\n    reset() {\n    }\n    interact(p1) {\n        var _a;\n        const container = this.container;\n        const linkOpt1 = p1.particlesOptions.links;\n        const optOpacity = linkOpt1.opacity;\n        const optDistance = (_a = p1.linksDistance) !== null && _a !== void 0 ? _a : container.retina.linksDistance;\n        const canvasSize = container.canvas.size;\n        const warp = linkOpt1.warp;\n        const pos1 = p1.getPosition();\n        const range = warp\n            ? new Utils_1.CircleWarp(pos1.x, pos1.y, optDistance, canvasSize)\n            : new Utils_1.Circle(pos1.x, pos1.y, optDistance);\n        const query = container.particles.quadTree.query(range);\n        for (const p2 of query) {\n            const linkOpt2 = p2.particlesOptions.links;\n            if (p1 === p2 || !linkOpt2.enable || linkOpt1.id !== linkOpt2.id || p2.spawning || p2.destroyed) {\n                continue;\n            }\n            const pos2 = p2.getPosition();\n            let distance = Utils_1.NumberUtils.getDistance(pos1, pos2);\n            if (warp) {\n                if (distance > optDistance) {\n                    const pos2NE = {\n                        x: pos2.x - canvasSize.width,\n                        y: pos2.y,\n                    };\n                    distance = Utils_1.NumberUtils.getDistance(pos1, pos2NE);\n                    if (distance > optDistance) {\n                        const pos2SE = {\n                            x: pos2.x - canvasSize.width,\n                            y: pos2.y - canvasSize.height,\n                        };\n                        distance = Utils_1.NumberUtils.getDistance(pos1, pos2SE);\n                        if (distance > optDistance) {\n                            const pos2SW = {\n                                x: pos2.x,\n                                y: pos2.y - canvasSize.height,\n                            };\n                            distance = Utils_1.NumberUtils.getDistance(pos1, pos2SW);\n                        }\n                    }\n                }\n            }\n            if (distance > optDistance) {\n                return;\n            }\n            const opacityLine = (1 - distance / optDistance) * optOpacity;\n            const linksOptions = p1.particlesOptions.links;\n            let linkColor = linksOptions.id !== undefined\n                ? container.particles.linksColors.get(linksOptions.id)\n                : container.particles.linksColor;\n            if (!linkColor) {\n                const optColor = linksOptions.color;\n                linkColor = Utils_1.ColorUtils.getLinkRandomColor(optColor, linksOptions.blink, linksOptions.consent);\n                if (linksOptions.id !== undefined) {\n                    container.particles.linksColors.set(linksOptions.id, linkColor);\n                }\n                else {\n                    container.particles.linksColor = linkColor;\n                }\n            }\n            if (p2.links.map((t) => t.destination).indexOf(p1) === -1 &&\n                p1.links.map((t) => t.destination).indexOf(p2) === -1) {\n                p1.links.push({\n                    destination: p2,\n                    opacity: opacityLine,\n                });\n            }\n        }\n    }\n}\nexports.Linker = Linker;\n"]},"metadata":{},"sourceType":"script"}